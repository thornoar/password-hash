\documentclass[12pt, a4paper]{article}
\input{preamble}

\input{Theorem_eng}

\makeatletter
\let\ps@plain\ps@empty
\makeatletter

\geometry{top = 1in, bottom = 1in, left = 1in, right = 1in}

\usepackage{tempora}

\renewcommand{\C}{\mathcal{C}}
\renewcommand{\S}{\mathcal{S}}

\newcommand{\dop}{\mathbin{{+}\hspace{-1mm}{+}}}

\newcommand{\spr}[1]{\mathrm{spr}(#1)}

% \usepackage{stix}

% \usepackage[default]{fontsetup} % New Computer Modern Book
% \newcommand\catenate{\mathbin{\text{\ttfamily\upshape ++}}}

\usepackage{mathtools, leftindex}

\newcommand{\lli}[1]{\leftindex_#1}
\newcommand{\lui}[1]{\leftindex^#1}

% \renewcommand{\mod}{\textbackslash}
% \renewcommand{\div}{\mathbin{\hspace{-.6mm}/\hspace{-.6mm}}}

\begin{document}

\thispagestyle{empty}
\vspace*{.6in}
{ \Huge\bfseries On rearrangement hashing with Haskell }\par
\vspace*{.1in}
{ \Large Roman Maksimovich }
\par
\vspace*{3.5in}
{ \Large\bfseries Abstract }\par
\vspace*{.1in}
\hrule
\vspace*{.1in}
\begin{minipage}{0.9\textwidth}
    In this paper I introduce and develop a mathematical method of producing a cryptographic hash of adjustable length, given a public key and a private key. The hashing is done through encoding selections and permutations with natural numbers, and then composing the hash from a set of source strings with respect to the permutations encoded by the keys. The attempts to construct a suitable integer-to-selection mapping leads to interesting mathematical definitions and statements, which are discussed in this paper and applied to give bounds on the reliability of the hashing algorithm. An implementation is provided in the Haskell programming language (source available at \url{https://github.com/thornoar/password-hash}) and applied in the setting of password creation. In the paper, the details of the implementation are discussed, as well as the connections between it and the corresponding mathematical model.
\end{minipage}
\vspace*{.1in}
\hrule
\vspace*{.2in}
\begin{center}
    \includegraphics[width = 1in]{./figures/haskell.png}
    \vfill
    \today
\end{center}

\newpage
\tableofcontents
\newpage

\section{Introduction}

The motivation behind the topic lies in the management of personal passwords. Nowadays, the average person requires tens of different passwords for different websites and services. Overall, one can distinguish between two ways of managing this set of passwords:

\begin{enumerate}
    \item \textbf{Keeping everything in one's head.} This is a method employed by many, yet it inevitably leads to certain risks. First of all, in order to fit the passwords in memory, one will probably make them similar to each other, or at least have them follow a simple pattern like "[shortened name of website]+[fixed phrase]". As a result, if even one password is guessed or leaked, it will be almost trivial to retrieve most of the others, following the pattern. Furthermore, the passwords themselves will tend to be memorable and connected to one's personal life, which will make them easier to guess. There is, after all, a limit to one's imagination.
    \item \textbf{Storing the passwords in a secure location.} Arguably, this is a better method, but there is a natural risk of this location being revealed, or of the passwords being lost, especially if they are stored physically on a piece of paper. Currently, various "password managers" are available, which are software programs that will create and store your passwords for you. It is usually unclear, however, how this software works and whether it can be trusted with one's potentially very sensitive passwords. After all, guessing the password to the password manager is enough to have all the other passwords exposed.
\end{enumerate}

In this paper I suggest a way of doing neither of these things. The user will not know the passwords or have any connection to them whatsoever, and at the same time the passwords will not be stored anywhere, physically or digitally. In this system, every password is a cryptographic hash produced by a fixed hashing algorithm. The algorithm requires two inputs: the public key, i.e. the name of the website or service, and the private key, which is an arbitrary positive integer known only to the user. Every time when retrieving a password, the user will use the keys to re-create it from scratch. Therefore, in order to be reliable, the algorithm must be "pure", i.e. must always return the same output given the same input. Additionally, the algorithm must be robust enough so that, even if a hacker had full access to it and its working, they would still not be able to guess the user's private key or the passwords that it produces. These considerations naturally lead to exploring pure mathematical functions as hashing algorithms and implementing them in a functional programming language such as Haskell.

\section{The theory}

There are many ways to generate hash strings. In our case, these strings are potential passwords, meaning they should contain lower-case and upper-case letters, as well as numbers and special characters. Instead of somehow deriving such symbol sequences directly from the public and private keys, we will be creating the strings by selecting them from a pre-defined set of distinct elements (i.e. the English alphabet or the digits from 0 to 9) and rearranging them. The keys will play a role in determining the rearrangement scheme. With regard to this strategy, some preliminary definitions are in order.

\subsection{Preliminary terminology}

Symbols $ A $, $ B $, $ C $ will denote arbitrary sets (unless specified otherwise). $ \N_0 $ is the set of all non-negative integers.

By $ E $ (and, similarly, $ E_1 $, $ E_2 $, $ E_3 $, etc.) we will denote a \emph{finite} set of distinct elements, called a \emph{source}. When multiple sources $ E_1 $, $ E_2 $, ..., $ E_N $ are considered, we take none of them to share any elements between each other. In other words, their pair-wise intersections will be assumed to be empty. By $ |E| $ we will denote the cardinality of a source $ E $, and $ E[i] $ will represent its $ i $-th element, with the numeration starting from $ i = 0 $.

The expression $ [A] $ will denote the set of all \emph{ordered} lists composed from elements of the set $ A $. The subset $ [A]_m \subset [A] $ will include only the lists of length $ m $. Extending the notation, by $ [A_1, A_2, ..., A_N] $ we will denote the set of lists $ \alpha = [a_1, a_2, ..., a_N] $ of length $ N $ where the first element is from $ A_1 $, the second from $ A_2 $, and so on, until the last one from $ A_N $. If $ \alpha \in [A] $ and $ \beta \in [B] $, the list $ \alpha \dop \beta \in [A \cup B] $ will denote the concatenation of lists $ \alpha $ and $ \beta $.

Let $ k \in \N_0 $, $ n \in \N $. The numbers $ \lui{N}k, \lli{N}k \in \N_0 $ are defined to be such that $ 0 \lle \lui{N}k < N $ and $ \lli{N}k \cdot N + \lui{N}k = k $. The number $ \lui{N}k $ is the remainder after division by $ N $, and $ \lli{N}k $ is the result of division.

For a number $ N \in \N $, the expression $ (N) $ will represent the semi-open integer interval from 0 to $ N $: $ (N) = \{0, 1, ..., N-1\} $.

Let $ n, m \in \N $, $ m \lle n $. The quantity $ \frac{n!}{(n-m)!} $ will be called a \emph{relative factorial} and denoted by $ (n \mid m)! $\ .

\subsection{Enumerating list selections}

The defining feature of the public key is that it is either publicly known or at least very easy to guess. Therefore, it should play little role in actually encrypting the information stored in the private key. It exists solely for the purpose of producing different passwords with the same private key. So for now we will forget about it. In this and the following subsection we will focus on the method of mapping a private key $ k \in \N_0 $ to an ordered selection from a set of sources in an effective and reliable way.

\begin{definition}
    Let $ E $ be a source, $ k \in \N_0 $. The \emph{choice function of order 1} is defined as follows:
    \[ \C(k, E, 1) = E[k\mod |E|]. \] 
\end{definition}

It corresponds to picking one element from the source according to the key. For a fixed source $ E $, the choice function is periodic with a period of $ |E| $ and is injective  on the interval $ (|E|) $. Injectivity is a very important property for a hashing function, since it determines the number of keys that produce different outputs. When describing injectivity on intervals, the following definition proves useful:

\begin{definition}
    Let $ A $ be a finite set and let $ f \colon \N_0 \to A $ be a function. The \emph{spread} of $ f $ is defined to the largest number $ n $ such that, for all $ k_1, k_2 \in \N_0 $, $ k_1 \ne k_2 $, the following implication holds:
    \[ f(k_1) = f(k_2) \implies |k_1 - k_2| \gge n. \]
    This number exists since $ A $ is finite. It will be denoted by $ \spr{f} $.
\end{definition}

Trivially, if $ \spr{f} \gge n $, then $ f $ is injective on $ (n) $, but the inverse is not always true. Therefore, a lower bound on the spread of a function serves as a guarantee of its injectivity. Furthermore, if $ \spr{f} \gge n $ and $ f $ is bijective on $ (n) $, then $ f $ is periodic with period $ n $. We leave this as an exercise for the reader.

\begin{proposition}
    Let $ f \colon \N_0 \to A $, $ g \colon \N_0 \to B $ be functions such that $ \spr{f} \gge n $ and $ \spr{g} \gge m $. Define the function $ h \colon \N_0 \to [A, B] $ as follows:
    \[ h(k) = [f(\lui{n}k), g(\lli{n}k + T(\lui{n}k))], \]
    where $ T \colon \N_0 \to \N_0 $ is a fixed "shift function". It is then stated that $ \spr{h} \gge nm $.
\end{proposition}
\begin{proof}
    Assume that $ k_1 \ne k_2 $ and $ h(k_1) = h(k_2) $. Since $ h $ returns an ordered list, the equality of lists is equivalent to the equality of all their corresponding elements:
    \begin{gather}
        f(\lui{n}k_1) = f(\lui{n}k_2),\label{one}\\
        g(\lli{n}k_1 + T(\lui{n}k_1)) = g(\lli{n}k_2 + T(\lui{n}k_2)).\label{two}
    \end{gather}
    Since $ f $ is injective on $ (n) $, we see that $ \lui{n}k_1 = \lui{n}k_2 $. Consequently, it follows from $ k_1 \ne k_2 $ that $ \lli{n}k_1 \ne \lli{n}k_2 $ and $ \lli{n}k_1 + T(\lui{n}k_1) \ne \lli{n}k_2 + T(\lui{n}k_2) $. We can then proceed to utilize the definition of spread for the function $ g $:
    \begin{align*}
    | \lli{n}k_1 + T(\lui{n}k_1) - \lli{n}k_2 - T(\lui{n}k_2) | &\gge m,\\[1mm]
    | \lli{n}k_1 - \lli{n}k_2 | &\gge m,\\[1mm]
    \left| \frac{k_1 - \lui{n}k_1}{n} - \frac{k_2 - \lui{n}k_2}{n} \right| &\gge m,\\[1mm]
    \left| \frac{k_1 - k_2}{n} \right| &\gge m,\\[1mm]
    | k_1 - k_2 | &\gge nm.
    \end{align*}
\end{proof}

With this proposition at hand, we have a natural way of extending the definition of the choice function:

\begin{definition}
    Let $ E $ be a source with cardinality $ |E| = n $, $ k \in \N_0 $, $ 2 \lle m \lle |E| $. The \emph{choice function of order $ m $} is defined recursively as
    \[ \C(k, E, m) = [E[\lui{n}k],\ \ \C(\lli{n}k + T(\lui{n}k),\ E\textbackslash\lui{n}k,\ m-1)] \] 
\end{definition}

\end{document}
